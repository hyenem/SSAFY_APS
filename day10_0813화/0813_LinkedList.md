# LinkedList
## 특성
* 논리적 : 사람이 이해하는 구조 / 물리적 : 실제 컴퓨터 메모리 상에 저장되는 구조
* 자료의 논리적인 순서와 메모리상의 물리적 순서가 일치하지 않고, 개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조를 이룬다.
* 링크를 통해 원소에 접근하므로, 순차 리스트와 같이 물리적인 순서를 맞추기 위한 작업이 필요하지 않다.
* 자료구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적인 사용이 가능하다.

## 구조
### 노드
* 연결 리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료 단위
* 구성 요소
    * 데이터 필드
        * 원소의 값을 저장하는 자료구조
        * 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용함
    * 링크 필드
        * 다음 노드의 주소를 저장하는 자료구조
### 헤드
* 리스트의 시작 위치에 해당하는 노드
* 링크 필드만 있으면 됨. 데이터 필드는 필요 없음.

## 종류
### 단순 연결 리스트
* 단방형 연결 리스트
* 연결 구조
    * 노드가 `하나`의 링크 필드에 의해 다음 노드와 연결되는 구조를 가진다.
    * 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킨다.
    * 최종적으로 NULL을 가리키는 노드가 리스트의 마지막 노드이다.
* 구현방법
    * head가 첫 번쨰 데이터를 가지는 Node
        * 데이터를 다 지우면 NULL이 됨. 다시 노드를 추가하려면 예외처리를 해줘야함(null일 경우 새로운 노드 추가, 아니면 노드 연결)
    * head가 빈 데이터를 가지는 더미 노드
        * 헤드가 항상 고정이고, 구현이 좀 더 쉽다는 장점이 있다.
        * 데이터를 다 지워도 헤드가 남아 있음. 빈 상황에서도 추가 연산의 케이스가 분류되지 않음.
        * 모든 연산을 중간 삽입, 중간 삭제인 것 처럼 취급할 수 있음. 전자의 경우 헤드에 대해 예외처리를 해줘야함.
        * 하지만 메모리 사용량이 높아진다는 단점이 있음.(사이즈가 커지면 사실상 무의미 하긴함)
* 원소의 삽입 (A-> C-> D 에 B 삽입)
    * 새로운 노드 생성 후 데이터 필드에 B를 저장
    * 새로은 노드의 링크를 C에 연결
    * A의 링크를 새로운 노드에 연결
        * 항상 새로운 노드부터 연결을 해줄 것.
        * 그러면 기존 리스트는 연결 관계를 유지하게 되어서 더 안전함.
* 원소의 삭제 (A->B->C->D에서 B 삭제)
    * curr : 삭제할 노드의 앞 노드
    * curr.link 를 curr.link.link로 바꿔줌.

### 이중 연결 리스트
* 특성
    * 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
    * 두 개의 링크 필드와 한 개의 데이터 필드로 구성
    * 두 링크는 방향을 구분하기 위해서 prev와 next로 표현함.

* 원소의 삽입
    * 메모리를 할당해 새로운 노드를 생성하고 데이터 필드에 데이터를 저장.
    * 바로 이전 노드인 curr 찾기
    * 새로운 노드의 prev = curr, next = curr.link
    * curr.next = new, curr.next.prev = new;
* 원소의 삭제
    * 지울 노드 찾아서 rmNode로 저장
    * rmNode.prev.next = rmNode.next;
    * rmNode.next.prev = rmNode.prev;
    * //
    * 이전 노드 찾아서 curr로 저장
    * curr.next.next.prev = curr;
    * curr.next = curr.next.next;
    * //
    * 이전 노드 찾아서 curr로 저장
    * curr.next=curr.next.next;
    * curr.next.prev = curr;

## 배열과 연결리스트 비교
* 배열로 구현하면 크기 고정
* 연결 리스트로 구현하면 동적 크기 조절 가능

* 우선순위 큐를 만들 때에도
    * 배열을 사용하면 삽입이나 삭제 연산이 일어날 때마다 원소의 재배치가 필요함
    * 이를 연결리스트를 이용하면 해결할 수 있다.(재배치 필요없음)

    |구분|배열|연결리스트|
    |:---:|:----:|:----:|
    |삽입, 삭제|O(N)|O(1)|
    |조회|O(1)|O(N)|