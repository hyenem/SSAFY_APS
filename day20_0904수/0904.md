# 서로소 집합
* 상호 배타 집합
* 중복 포함된 원소가 없는 집합 -> 교집합 이 없음
* 각 집합은 대표자를 통해서 구분

## 상호 배타 집합의 표현 방법
* 연결 리스트
    * 링크가 내 뒤의 노드와 대표를 가리키는 두 개가 있음
* 트리
    * 루트 노드가 대표자가 됨
    * 각 노드에 인덱스를 결정한뒤, 해당 인덱스에 그 노드의 바로 조상 노드를 저장함.

## 상호 배타 집합 연산
* Make-set(x) : x를 대표로 하는 집합을 생성하겠다.
* Find-set(x) : x가 속한 집합의 대표 가져와
* Union(x, y)
    * x와 y의 집합을 하나로
    * Find-set을 통해서 대표를 얻어오고, 대표를 바탕으로 합치는 과정이 필요함

## 개선점
* find-set을 할 때마다 매번 재귀호출이 일어나서 계속계속 끝까지 올라가야하는 단점이 있음
* 연산의 효율을 높이는 방법이 없을까?
    * Rank를 이용한 Union 
        * 각 노드는 자신을 루트로 하는 subtree의 높이를 rank라는 이름으로 저장
        * 두 집합을 union할 때 rank가 낮은 집합을 높은 집합에 붙인다.
        * 최대한 균형을 이루면서 트리가 너무 한 쪽으로만 깊어지지 않도록 함
        * 만약 랭크가 같다면 아무대나 붙이고 랭크 조정을 해줌
    * Path compression
        * find set을 행하는 과정에서 만나는 모든 노드들이 직접 대표를 가리키도록 수정한다.


# 최소 신장 트리
* 도로망, 통신망, 유통망 등등 여러 분야에서 비용을 최소로 해야 이익을 볼 ㅅ ㅜ있다.
* 크루스칼, 프림이 있음

## KRUSKAL 알고리즘
1. 최초 모든 간선을 가중치에 따라 오름차순으로 정렬
2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
    * 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
3. N-1 개의 간선이 선택될 때까지 2 반복
